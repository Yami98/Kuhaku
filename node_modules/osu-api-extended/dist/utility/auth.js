"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.refresh_session = exports.authorize = exports.build_url = exports.refresh_token = exports.set_v2 = exports.login = exports.cache = exports.credentials = exports.settings = void 0;
const child_process_1 = require("child_process");
const request_1 = require("./request");
const readline_1 = __importDefault(require("readline"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const handleErrors_1 = require("./handleErrors");
exports.settings = {
    timeout: 60000,
    throwErrors: true,
};
exports.credentials = {
    type: '',
    api_key: '',
    client_id: '',
    client_secret: '',
    login: '',
    password: '',
    redirect_url: '',
    state: '',
    cachedTokenPath: '',
    scopes: ['public'],
};
exports.cache = {
    v1: '',
    v2: '',
    'ratelimit-remaining': 1200,
    'ratelimit-limit': 1200,
};
const login = (params) => {
    if ((params === null || params === void 0 ? void 0 : params.type) == null) {
        return (0, handleErrors_1.handleErrors)(new Error('Specify login type'));
    }
    ;
    exports.credentials.type = params.type;
    if (params.cachedTokenPath)
        exports.credentials.cachedTokenPath = params.cachedTokenPath;
    if (params.timeout)
        exports.settings.timeout = params.timeout;
    if (params.type == 'v1') {
        exports.credentials.api_key = params.api_key;
        exports.cache.v1 = params.api_key;
        return exports.cache.v1;
    }
    ;
    if (params.type == 'v2') {
        exports.credentials.client_id = params.client_id;
        exports.credentials.client_secret = params.client_secret;
        if (params.scopes)
            exports.credentials.scopes = params.scopes;
        return client_login(params.client_id, params.client_secret, params.scopes || ['public']);
    }
    ;
    if (params.type == 'lazer') {
        exports.credentials.login = params.login;
        exports.credentials.password = params.password;
        return lazer_login(params.login, params.password);
    }
    ;
    if (params.type == 'cli') {
        exports.credentials.client_id = params.client_id;
        exports.credentials.client_secret = params.client_secret;
        if (params.scopes)
            exports.credentials.scopes = params.scopes;
        exports.credentials.redirect_url = params.redirect_url;
        exports.credentials.state = params.state;
        return authorize_cli(params.client_id, params.client_secret, params.redirect_url, params.scopes || ['public'], params.state);
    }
    ;
    return null;
};
exports.login = login;
const set_v2 = (token) => exports.cache.v2 = token;
exports.set_v2 = set_v2;
const refresh_token = () => __awaiter(void 0, void 0, void 0, function* () {
    const refresh = yield (0, exports.login)(exports.credentials);
    return refresh;
});
exports.refresh_token = refresh_token;
const token_exists = () => {
    if (!fs_1.default.existsSync(exports.credentials.cachedTokenPath))
        return false;
    try {
        const authData = JSON.parse(fs_1.default.readFileSync(exports.credentials.cachedTokenPath, 'utf8'));
        (0, exports.set_v2)(authData.access_token);
        if (Array.isArray(authData.scopes))
            exports.credentials.scopes = authData.scopes;
        return true;
    }
    catch (error) {
        return false;
    }
    ;
};
const save_token = (response) => {
    if (!exports.credentials.cachedTokenPath)
        return;
    const { dir } = path_1.default.parse(exports.credentials.cachedTokenPath);
    if (fs_1.default.existsSync(dir))
        fs_1.default.mkdirSync(dir, { recursive: true });
    response.scopes = exports.credentials.scopes;
    fs_1.default.writeFileSync(exports.credentials.cachedTokenPath, JSON.stringify(response), 'utf8');
};
const client_login = (client_id, client_secret, scopes) => __awaiter(void 0, void 0, void 0, function* () {
    if (exports.cache.v2 == '' && exports.credentials.cachedTokenPath != '') {
        const is = token_exists();
        if (is)
            return;
    }
    ;
    const response = yield (0, request_1.request)('https://osu.ppy.sh/oauth/token', {
        method: 'POST',
        headers: {
            "Accept": "application/json",
            "Content-Type": "application/json",
        },
        data: JSON.stringify({
            grant_type: 'client_credentials',
            client_id: client_id,
            client_secret: client_secret,
            scope: scopes.join(' '),
            code: 'code',
        })
    });
    if (response.error)
        return (0, handleErrors_1.handleErrors)(new Error(response.error));
    exports.cache.v2 = response.access_token;
    save_token(response);
    return response;
});
const lazer_login = (login, password) => __awaiter(void 0, void 0, void 0, function* () {
    if (exports.cache.v2 == '' && exports.credentials.cachedTokenPath != '') {
        const is = token_exists();
        if (is)
            return;
    }
    ;
    const response = yield (0, request_1.request)('https://osu.ppy.sh/oauth/token', {
        method: 'POST',
        headers: {
            "Accept": "application/json",
            "Content-Type": "application/json",
        },
        data: JSON.stringify({
            username: login,
            password: password,
            grant_type: "password",
            client_id: 5,
            client_secret: 'FGc9GAtyHzeQDshWP5Ah7dega8hJACAJpQtw6OXk',
            scope: "*"
        })
    });
    if (response.error)
        return (0, handleErrors_1.handleErrors)(new Error(response.error));
    exports.cache.v2 = response.access_token;
    save_token(response);
    return response;
});
const authorize_cli = (client_id, client_secret, redirect_url, scopes, state) => __awaiter(void 0, void 0, void 0, function* () {
    if (exports.cache.v2 == '' && exports.credentials.cachedTokenPath != '') {
        const is = token_exists();
        if (is)
            return;
    }
    ;
    const cl = readline_1.default.createInterface(process.stdin, process.stdout);
    const question = (q) => new Promise((res, rej) => cl.question(q + ': ', (answer) => res(answer)));
    const url = (0, exports.build_url)({ client_id, redirect_url, scopes, state });
    const start = (process.platform == 'darwin' ? 'open' : process.platform == 'win32' ? 'start' : 'xdg-open');
    (0, child_process_1.execSync)(start + ' ' + url.replace(/&/g, '^&'));
    const code = yield question('Paste code here');
    const response = yield (0, request_1.request)('https://osu.ppy.sh/oauth/token', {
        method: 'POST',
        headers: {
            "Accept": "application/json",
            "Content-Type": "application/json",
        },
        data: JSON.stringify({
            grant_type: 'authorization_code',
            client_id: client_id,
            client_secret: client_secret,
            redirect_uri: redirect_url,
            code,
        })
    });
    if (response.error)
        return (0, handleErrors_1.handleErrors)(new Error(response.error));
    exports.cache.v2 = response.access_token;
    save_token(response);
    return response;
});
const build_url = ({ client_id, redirect_url, scopes, state }) => {
    const url = new URL('https://osu.ppy.sh/oauth/authorize');
    const params = {
        client_id: client_id,
        redirect_uri: redirect_url,
        response_type: 'code',
        scope: scopes.join(' '),
    };
    if (state)
        params.state = state;
    Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));
    return url.href;
};
exports.build_url = build_url;
const authorize = (params) => __awaiter(void 0, void 0, void 0, function* () {
    if ((params === null || params === void 0 ? void 0 : params.client_id) == null) {
        return (0, handleErrors_1.handleErrors)(new Error(`Specify client_id`));
    }
    ;
    if ((params === null || params === void 0 ? void 0 : params.client_secret) == null) {
        return (0, handleErrors_1.handleErrors)(new Error(`Specify client_secret`));
    }
    ;
    if ((params === null || params === void 0 ? void 0 : params.redirect_url) == null) {
        return (0, handleErrors_1.handleErrors)(new Error(`Specify redirect_url`));
    }
    ;
    if ((params === null || params === void 0 ? void 0 : params.code) == null) {
        return (0, handleErrors_1.handleErrors)(new Error(`Specify code`));
    }
    ;
    const response = yield (0, request_1.request)('https://osu.ppy.sh/oauth/token', {
        method: 'POST',
        headers: {
            "Accept": "application/json",
            "Content-Type": "application/json",
        },
        data: JSON.stringify({
            grant_type: 'authorization_code',
            client_id: params.client_id,
            client_secret: params.client_secret,
            redirect_uri: params.redirect_url,
            code: params.code,
        })
    });
    if (response.error)
        return (0, handleErrors_1.handleErrors)(new Error(response.error));
    let url = 'https://osu.ppy.sh/api/v2/me';
    if (params === null || params === void 0 ? void 0 : params.mode)
        url += `/${params.mode}`;
    const user = yield (0, request_1.request)(url, {
        method: 'GET',
        addons: { authKey: response.access_token, ignoreSessionRefresh: true }
    });
    if (user.error)
        return (0, handleErrors_1.handleErrors)(new Error(user.error));
    user.access_token = response.access_token;
    user.refresh_token = response.refresh_token;
    user.expires_in = response.expires_in;
    return user;
});
exports.authorize = authorize;
const refresh_session = (params) => __awaiter(void 0, void 0, void 0, function* () {
    if ((params === null || params === void 0 ? void 0 : params.client_id) == null) {
        return (0, handleErrors_1.handleErrors)(new Error(`Specify client_id`));
    }
    ;
    if ((params === null || params === void 0 ? void 0 : params.client_secret) == null) {
        return (0, handleErrors_1.handleErrors)(new Error(`Specify client_secret`));
    }
    ;
    if ((params === null || params === void 0 ? void 0 : params.redirect_url) == null) {
        return (0, handleErrors_1.handleErrors)(new Error(`Specify redirect_url`));
    }
    ;
    if ((params === null || params === void 0 ? void 0 : params.refresh_token) == null) {
        return (0, handleErrors_1.handleErrors)(new Error(`Specify refresh_token`));
    }
    ;
    const response = yield (0, request_1.request)('https://osu.ppy.sh/oauth/token', {
        method: 'POST',
        headers: {
            "Accept": "application/json",
            "Content-Type": "application/json",
        },
        data: JSON.stringify({
            grant_type: 'refresh_token',
            client_id: params.client_id,
            client_secret: params.client_secret,
            redirect_uri: params.redirect_url,
            refresh_token: params.refresh_token,
        })
    });
    if (response.error)
        return (0, handleErrors_1.handleErrors)(new Error(response.error));
    let url = 'https://osu.ppy.sh/api/v2/me';
    if (params === null || params === void 0 ? void 0 : params.mode)
        url += `/${params.mode}`;
    const user = yield (0, request_1.request)(url, {
        method: 'GET',
        addons: { authKey: response.access_token, ignoreSessionRefresh: true }
    });
    if (user.error)
        return (0, handleErrors_1.handleErrors)(new Error(user.error));
    user.access_token = response.access_token;
    user.refresh_token = response.refresh_token_new;
    user.expires_in = response.expires_in;
    return user;
});
exports.refresh_session = refresh_session;
